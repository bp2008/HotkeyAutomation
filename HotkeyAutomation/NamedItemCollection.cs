using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace HotkeyAutomation
{
	/// <summary>
	/// A thread-safe collection of named items which may only be accessed by the public methods of this class.
	/// </summary>
	/// <typeparam name="T"></typeparam>
	public class NamedItemCollection<T> where T : NamedItem, new()
	{
		/// <summary>
		/// Do not reference this directly. This is only public so it will be serialized properly.
		/// </summary>
		public List<T> items = new List<T>();
		private string type;
		public NamedItemCollection()
		{
			type = typeof(T).Name;
			if (type.EndsWith("Controller"))
				type = type.Substring(0, type.Length - "Controller".Length);
		}

		/// <summary>
		/// Gets the item with the specified name, or null.
		/// </summary>
		public T Get(string name)
		{
			lock (this)
				return items.FirstOrDefault(h => h.name == name);
		}
		/// <summary>
		/// Gets the item with the specified id, or null.
		/// </summary>
		public T Get(int id)
		{
			lock (this)
				return items.FirstOrDefault(h => h.id == id);
		}
		/// <summary>
		/// Gets a snapshot of the existing names of all items as an array.
		/// </summary>
		/// <returns></returns>
		public string[] Names()
		{
			lock (this)
				return items.Select(i => i.name).ToArray();
		}
		/// <summary>
		/// Gets a snapshot of the existing items as an array.
		/// </summary>
		/// <returns></returns>
		public T[] List()
		{
			lock (this)
				return items.ToArray();
		}

		/// <summary>
		/// Creates a new item, adds it to the collection, and returns the item.  Returns null if a new item could not be created (due to all the autogenerated names being used).
		/// </summary>
		/// <returns></returns>
		public T New()
		{
			lock (this)
			{
				T newItem = new T();
				for (int i = 1; i < 1000; i++)
				{
					newItem.name = "New " + type + " " + i;
					if (Get(newItem.name) == null)
						break;
				}
				if (Get(newItem.name) == null)
				{
					int newId = items.Count == 0 ? 0 : items.Max(h => h.id) + 1;
					while (Get(newId) != null)
						newId++;
					newItem.id = newId;
					items.Add(newItem);
					return newItem;
				}
				return null;
			}
		}
		/// <summary>
		/// Updates the item based on its id. Returns true if successful, or false if the updated name already exists or if no item with the ID was found.
		/// </summary>
		public bool Update(T item)
		{
			lock (this)
			{
				for (int i = 0; i < items.Count; i++)
				{
					if (items[i].id == item.id)
					{
						T existingName = Get(item.name);
						if (existingName != null && existingName.id != item.id)
							return false; // A different item already has this name.
						items[i] = item;
						return true;
					}
				}
				return false; // Item not found.
			}
		}
		/// <summary>
		/// Deletes the item with the specified name, if it exists.
		/// </summary>
		public void Delete(string name)
		{
			lock (this)
			{
				for (int i = 0; i < items.Count; i++)
				{
					if (items[i].name == name)
					{
						items.RemoveAt(i);
						return;
					}
				}
			}
		}
		/// <summary>
		/// Deletes the item with the specified id, if it exists.
		/// </summary>
		public void Delete(int id)
		{
			lock (this)
			{
				for (int i = 0; i < items.Count; i++)
				{
					if (items[i].id == id)
					{
						items.RemoveAt(i);
						return;
					}
				}
			}
		}
		/// <summary>
		/// Returns the first item to meet the specified condition, or null.
		/// </summary>
		/// <param name="predicate">A function which returns true if the item meets the condition.</param>
		/// <returns></returns>
		public T FirstOrDefault(Func<T, bool> predicate)
		{
			lock (this)
				return items.FirstOrDefault(predicate);
		}
		/// <summary>
		/// Returns all items which meet the specified condition.
		/// </summary>
		/// <param name="predicate">A function which returns true if the item meets the condition.</param>
		/// <returns></returns>
		public IEnumerable<T> Where(Func<T, bool> predicate)
		{
			lock (this)
				return items.Where(predicate);
		}
		/// <summary>
		/// Reorders the items to match the order of the given ids.
		/// </summary>
		/// <param name="ids">A collection of item ids in the desired order.</param>
		/// <returns></returns>
		public bool Reorder(ICollection<int> ids)
		{
			lock (this)
			{
				T[] snapshot = List();
				if (snapshot.Length != ids.Count)
					return false; // ids collection is a different length than our current snapshot
				if (ids.Count != ids.Distinct().Count())
					return false; // ids collection contains duplicates
				Dictionary<int, T> idToItemMap = new Dictionary<int, T>();
				foreach (int id in ids)
				{
					T item = snapshot.FirstOrDefault(obj => obj.id == id);
					if (item == null)
						return false; // One of the ids in the collection isn't in our snapshot
					else
						idToItemMap[id] = item;
				}
				// Commit order changes.
				int i = 0;
				foreach (int id in ids)
				{
					items[i] = idToItemMap[id];
					i++;
				}
				return true;
			}
		}
	}
}
